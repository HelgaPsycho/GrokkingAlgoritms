/*
 
    БИНАРНЫЙ ПОИСК
 
 key points:
 - Проводится в отсортированном массиве
 - Имеет логарифмическую сложность (время выполнения алгоритма) О(logn)
 - С каждым шагом проверяет средний элемент и отбрасывает половину элементов
 
*/


func binarySearch (array: [Int], item: Int) -> Int? {
    // функция принимает массив и искомый элемент, возвращает индекс искомого элемента или nil
    //индекс наименьшего элемента в массиве:
    var lowElementIndex = 0
    //индекс наибольшего элемента в массиве:
    var hightElementIndex = array.count - 1
    //цикл повторяется, пока массив не сократится до одного элемента
    while array[lowElementIndex] < array[hightElementIndex] {
    // проверяем средний элемент в массиве:
    let midElementIndex = (lowElementIndex + hightElementIndex)/2
    let guessElement = array[midElementIndex]

    if guessElement == item {
        //значение найдено
        return midElementIndex
    } else if guessElement < item {
        // если предполагаемое значение меньше искомого, то обновляется меньший элемент
        lowElementIndex = midElementIndex + 1
    } else if guessElement > item {
        // если предполагаемое значение больше искомого, то обновляется больший элемент
        hightElementIndex = midElementIndex - 1
    }
    }
return nil
}


print(binarySearch(array: [1, 3 ,4, 6, 7, 8, 8, 10], item: 6))

/* УПРАЖНЕНИЯ
1. Какое максимальное число проверок потребуется для списка из 128 имен?
 
 log 128 = 7
 
 2. Списко увеличился вдвое, как изменилось максимальное количество проверок
 
 на 1 проверку, т.е. 8 проверок
 
 3. Известна фамилия, нужно найти номер в тел. книге
 
 O (logn)
 
 4. Известен номер, нужно найти фамилию в тел. книге

 O(n)
 
 5. Нужно прочитать телефоны всех людей в тел. клиге
 
 О(n)
 
 6.Нужно прочитать телефоны всех людей, фалилии которых начинаются на "А"
 
 O(n) т.к. самый плохой вариант, когда все фамилии начинаются на "А"
 
 
 */
