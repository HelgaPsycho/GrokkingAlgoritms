/* АЛГОРИТМ ДЕЙСТРЫ
 Работает со взвешенными направленными ациклическими  (DAG - direct acyclic graph) графами с неотрицательными ребрами
 помогает найти кратчайший (самый дешевый) путь
 
 При наличии о
 
 4 шага
1. Найти узел с наименьшей стоимостью (то есть узел, до которого можно добраться за минимальное время).
 2. Проверить, существует ли более дешевый путь к соседям этого узла, и если существует, обновить из стоимости
 3. Повторять, пока это не будет сделано для всех узлов графа
 4. Вычислить итоговый путь
                
         5     |-----------|   15  |---------|
          ---->| пластинка | ----->| басуха  |---\ 20
         |     |___________|     __|_________|    \
 |-------|                20\__ /                  \->|---------|
 | книга |                   __ \__                   | пианино |
 |_______|                30/       \              /->|_________|
         | 0   |-----------|       |---------|    /
          ---->|   постер  | ----->| барабан |---/ 10
               |___________|   35  |_________|

 
 Работа метода на этом примере:
 
           6 --> A --1
          /      ^    \
|--------|       |     |-------|
| начало |       3     | конец |
|________|       |     |_______|
          \      |    /
           2 --> B --5
 
 Потребуется 3 хэш-таблицы:
 - Граф (graph)
 - Стоимости (costs) определяет, сколько времени потребуется для перехода к этому узлу от начального - будет обновляться по ходу работы
 - Родители (parents) - будет обновляться по ходу работы
 
 -------------------      --------------       --------------
  Граф             |     | Стоимости    |     |   Родители   |
 -------------------      --------------       --------------
 начало |  A   | 6 |     |   A   |   6  |     |   A   |   6  |
        |  B   | 2 |      --------------       ---------------
 -------------------     |   B   |   2  |     |   B   |   2  |
 А      |конец | 1 |      --------------       ---------------
 ___________________     | конец |   ∞  |     | конец |   -  |
 B      |  A   | 3 |      --------------       --------------
        |конец | 5 |
 -------------------
 конец  |    -     |
 -------------------
 
 */
// 1ая хэш-таблица - ГРАФЫ
let graph: [String: [String: Int]] = ["start": ["a": 6, "b": 2], "a": ["fin": 1], "b": ["a": 3, "fin": 5]]
// по-моему пользоваться таким словарем неудобно, сделаю отдельный тип данных для хранения узлов графа

struct Node: Hashable {
    let name: String
    var directions = [Node: Int]()
    
}

var startNode = Node(name: "start")
var aNode = Node(name: "A")
var bNode = Node(name: "B")
var finNode = Node(name: "final")

startNode.directions = [aNode: 6, bNode: 2]
aNode.directions = [finNode: 1]
bNode.directions = [aNode: 3, finNode: 5]

struct Graph {
    var nodes = [Node]()
}

var structGraph = Graph()
structGraph.nodes.append(contentsOf: [startNode, aNode, bNode, finNode])

var grahpArray = [startNode, aNode, bNode, finNode]

// 2ая ХЭШ таблица со СТОИМОСТЯМи (сколько времени потребуется для перехода к этому узлу от начального) будет обновляться по ходу работы
var costs: [Node: Int] = [aNode: 6, bNode: 2, finNode: Int.max]

//3я ХЭШ таблица - РОДИТЕЛИ

var parents: [Node: Node?] = [aNode: startNode, bNode: startNode, finNode: nil]

// массив для отслеживания всех уже обработанных узлов

var processedNodes = [Node]()

/*Подготовка закончилась. Переходим к алгоритму.
 
 АЛГОРИТМ
 1. Пока остаются необработанные узлы
 2. Взять узел, ближайший к началу
 3. Обновить стоимоть для его соседей
 4. Если стоимости каких-либо соседей были обновлены, обновить и родителей
 5. Пометить узел, как обработанный -> 1 шаг
 
*/







